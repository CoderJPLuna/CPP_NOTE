# 模板初阶

## 泛型编程

如何实现一个通用的交换函数？

```C++{.line-numbers}
template<class T>
void Swap(T& x1,T& x2)
{
    T x=x1;
    x1=x2;
    x2=x;
}
```

使用函数重载虽然可以实现，但有一下几个缺点：

1. 重载的函数仅仅只是类型不同，代码的复用率比较低，只要有新类型出现时，就需要增加对应的函数。
2. 代码的可维护性比较低，一个出错可能所有的重载均出错。

泛型编程：编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础。

## 函数模板

### 概念

函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本。

### 函数模板格式

template<typename T1,typename T2,……,typename Tn>

```C++{.line-numbers}
template<typename T>
void Swap(T& left,T& right)
{
    T temp=left;
    left=right;
    right=temp;
}
```

**注意**

typename是用来定义模板参数关键字，也可以使用class(切记不能用struct代替class)

### 函数模板的原理

函数模板是一个蓝图，它本身并不是函数，是编译器使用方式产生特定具体类型函数的模具。所以模板就是将本来应该重复做的事交给编译器。
在编译器的预处理阶段，对于模板函数的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用。

### 函数模板的实例化

用不同类型的参数使用函数模板时，称为函数模板的实例化。模板参数实例化分为：隐式实例化和显式实例化。

1. 隐式实例化：让编译器根据实参推演模板参数的实际类型。

```C++{.line-numbers}
template<class T>
T Add(const T& left,const T& right)
{
    return left+right;
}
int main()
{
    int a1=10;
    int a2=20;
    double d1=10.0;
    double d2=20.0;
    Add(a1,a2);
    Add(d1,d2);
    Add(a1,d1);//错误
    //该语句不能通过编译，因为在编译期间，当编译器看到该实例化时，需要推演其实参类型，通过实参a1将T推演为int，通过实参d1将T推演为double类型，但模板参数列表中只有一个T，编译器无法确定此处到底该将T确定为int还是double类型而报错
    //注意：在模板中，编译器一般不会进行类型转换操作，因为一旦转化出现问题，编译器就要背黑锅
    //此时有两种处理方式：1.用户自己来强制类型转化2.使用显式实例化
}